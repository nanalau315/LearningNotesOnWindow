Git: The Other Parts - From Rebasing to Custom Aliases and More

##### Rebasing #####
    - why rebase? we get a much cleaner project history. no unnecessary merge commits! We end up with a linear project history.
    - never rebase commits that have been shared with others. If you have already pushed commits up to Github, DO NOT rebase them unless you are positive no one on the team is using those commits.
    - !!! You do not want to rewrite any git history that other people already have. Its a pain to reconcile the alternate histories.
    - there are two main ways to use the git rebase command:
        - as an alternative to merging
            - by rebasing, it can move the entire feature branch so that it begins at the tip of the master branch. All of the work is still there, but we have re-written history. so instead of using a merge commit, rebasing rewrites history by creating new commits for each of the original feature branch commits
            - first run 
                > git switch <branch-name>
            - then run 
                > git rebase master
        - as a cleanup tool

##### Handling Conflicts and Rebasing #####
    - watch the last video in section 15: Rebasing

##### Cleaning Up History With Interactive Rebase #####
    - sometimes we want to rewrite, delete, rename, or evven reorder commits (before sharing them). We can do this using git rebase!
    - interactive rebase: running git rebase with the -i option will enter the interactive mode, which allows us to edit commits, add files, drop commits, etc. Note that we need to specify how far back we want to rewrite commits. Also, notice that we are not rebasing onto another branch. Instead, we are rebasing a series of commits onto the HEAD they currently are based on. Using the following command will lets you to rebase on the spot where you are at right now.
        > git rebase -i HEAD~<num of commits that you want to go back to edit/delete>
    - next, in our text editor, we'll see a list of commits alongside a list of commands that we can choose from. Here are a couple of the more commonly used commands:
        - pick: use the commit
        - reword: use the commit, but edit the commit message
        - edit: use commit, but stop for amending
        - fixup: use commit contents but meld it into previous commit and discard the commit message.
        - drop: remove commit

##### Git Tags #####
    - tags are pointer that refer to particular points in Git history. We can make a particular moment in time with a tag. Tags are most often used to mark version releases in projects (e.g. v2.1.0)
    - Think of tags as branch references that DO NOT CHANGE. Once a tag is created, it always refers to the same commit. It's just a label for a commit
    - There are two types of git tags we can use: lightweight and annotated tags.
    - lightweight tags are lightweight. they are just a name/label that points to a particular commit.
    - annotated tags store extra meta data including the authoe's name and email, the date, and a tagging message(like a commit message)
        > git tag => will print a list of all the tags in the current repository.
        > git tag -l "*beta*" => to search for tags that match a particular pattern by using the git tag -l and then passing in a wildcard pattern. For example, git tag -l "*beta*" will print a list of tags that include "beta" in their name
        > git checkout <tag> => same as checking out a branch or a specific branch
        > git diff <tag1> <tag2> => to compare the diff between two tags

##### Semantic versioning #####
    - the semantic versioning spec outlines a standardized versioning system for software releases. It provides a consistent way for developers to give meaning to their software releases (how big of a change is this release??) version consist of three numbers separated by periods. official website: https://semver.org/
        - intial release: 1.0.0
        - patch release: 1.0.1 
            - patch releases normally do not contain new features or significant changes. They typically signify bug fixes and other changes that do not impact how the code is used.
        - minor release: 1.1.0
            - minor releases signify that new features or functionality have been added, but the project is still backwards compatible. No breaking changes. The new functionality is optional and should not force users to rewrite their own code.
            - when a new minor releases, the patch number should be reset to 0.
        - major release: 2.0.0
            - major releases signify significant changes that is no longer backwards compatible. features may be removed or changed substantially.
        
##### Creating Lightweight Tags #####
    > git tag <tagname> => to create a lightweight tag. By default, git will create the tag referring to the commit that HEAD is referencing.
    > git tag -a <tagname> => to create an annotated tag. git will then open your default text editor and prompt you for additional information. Similar to git commit, we can also use the -m option to pass a message directly and forgo the opening of the text editor
    > git show <tagname> => will show you the information of the tag
    > git tag <tagname> <commit> => to tag an older commit by provide the commit hash
    > git tag -f <tagname> => git will yell at us if we try to reuse a tag that is already referring to a commit. If we use the -f option, we can FORCE our tag through.
    > git tag -d <tagname> => to delete a tag
    - By default, the gut push command doesn't transfer tags to remote servers. If you have a lot of tags that you want to push up at once, you ccan use the --tags option to the git push command. This will transfer all of your tags to the remote server that are not already there.
        > git push --tags => to push up all tags
        > git push <remote> <tagname> => to push up a single tag